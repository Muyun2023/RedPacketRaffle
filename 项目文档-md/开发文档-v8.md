# 抽奖项目组 - 开发文档

**1.此文档包含开发期各个任务的相关说明，每个任务均包含以下小节：**

**任务目标：**分条列出本任务里需要做的功能点

**执行与标准：**任务执行步骤及完成标准，提交日报时需要对应指标，重点留意【提交结果截图】的地方

**参考资料：**本次任务需要了解的一些相关知识、外部链接资料、设计思路等



**2.任务标题上的⭐代表了本任务的难度级别，级别说明：**

**1星：**简单，不需要任何思考，照着做就可以完成

**2星：**比较简单，按照步骤操作即可完成，但需要一些外部的资料做参考

**3星：**中等，需要有一定的基础技术储备才可以完成

**4星：**比较难，在任务执行过程中，需要具备一定的设计能力

**5星：**最难，在任务执行中，可能遇到大量软件设计相关方案，需要具备较强的理解力才可以顺利完成



# 1、准备环境⭐️⭐️

在项目开发中一般有多套环境。包括本地开发环境、测试环境、生产环境等。其中构建开发环境是指在我们日常工作所用的机器上，搭建起我们运行、开发代码所必须的一些服务和软件。本小节需要我们准备好开发环境，为后续任务的开发打好基础。



## 1.1 任务目标

**任务周期：1天**

1. 在工作机器上使用Vmware软件启动Centos7系统
2. 检查Centos7系统里的各种服务：Mysql、Redis、Rabbitmq、Minio
3. 在工作机器上，安装并验证以下软件：Jdk、Git、Idea



## 1.2 执行与验收

任务提示：任务执行中，可能需要参考的相关资料，见下方1.3小节

### 1.2.1 安装Vmware并启动Centos7系统

**1.安装Vmware软件**

根据工作机器的系统环境，自行下载并安装对应的包，确保安装完成后软件可以正常打开



**2.用Vmware启动Centos7系统**

已经提供完整的Centos7系统资料包，直接下载并按照视频配置启动即可，资料地址： 

https://pan.baidu.com/s/1USO-hNLMvLgWKOkWFhyu0w?pwd=13rv 



**3.验证Centos7启动成功**

Centos7启动后，用任意ssh客户端软件连:   192.168.64.100 ,   用户名密码都是 root

1. 进入命令行，执行：  docker ps
2. 确保呈现的列表中出现：Mysql，Redis，Rabbitmq，Minio     【提交结果截图】




### 1.2.2 检查Centos7里的服务

**1.Mysql服务验证**

使用Mysql任意客户端，连接Mysql数据库，确保可以正常打开数据库看到内部表结构【提交结果截图】

- host：192.168.64.100 
- port：3306
- user：root
- password：root



**2.Redis服务验证**

使用Redis任意客户端，连接上Redis服务，确保可以正常连接并能够读写数据【提交结果截图】

- host：192.168.64.100 
- port：6379



**3.Rabbitmq服务验证**

访问Rabbitmq控制台，确保成功打开管理界面 【提交结果截图】

- 地址：http://192.168.64.100:15672    
- 用户名：guest
- 密码：guest


![image-20231117上午94044863](images/image-20231117%E4%B8%8A%E5%8D%8894044863.png)



**4.Minio服务验证与配置**

打开并登录后台，在buckets菜单下创建prize，并给Anonymous设置访问权限， / 为 readonly：【提交结果截图】

- 地址： http://192.168.64.100:9006    
- 用户名：minioadmin
- 密码： minioadmin


![image-20231212下午15638990](images/image-20231212%E4%B8%8B%E5%8D%8815638990.png)



### 1.2.3 在工作电脑上搭建开发环境

**1.Jdk环境安装与配置**

完成本地Jdk环境搭建，版本1.8.x，确保结果如下（x代表的小版本号可忽略）【提交结果截图】

```shell
[root@iZbp11ablifhhtuuo4x4byZ ~]# java -version
java version "1.8.0_321"
Java(TM) SE Runtime Environment (build 1.8.0_321-b07)
Java HotSpot(TM) 64-Bit Server VM (build 25.321-b07, mixed mode)
```



**2.Git工具安装与验证**

完成Git Bash安装，能够正常使用git命令，输入git后确保结果如下【提交结果截图】

```shell
[root@iZbp11ablifhhtuuo4x4byZ ~]# git
usage: git [--version] [--help] [-c name=value]
           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]
           [-p|--paginate|--no-pager] [--no-replace-objects] [--bare]
           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]
           <command> [<args>]
```



**3.Idea安装**

下载并安装Idea开发软件，根据你笔记本的系统，自行下载对应平台的安装包，确保安装成功



## 1.3 参考资料

**1.硬件环境**

检查自己计算机的配置：

- 操作系统：Windows/Mac均可以，推荐使用win11系统

- 内存：最低8g，建议16g

- 硬盘：空闲60g以上



**2.软件与版本**

- Java环境：jdk 8+  https://www.oracle.com/java/technologies/downloads/#java8

- 开发工具：idea 2022+  https://www.jetbrains.com/idea/download

- 项目编译：maven 3.6.x  https://maven.apache.org/download.cgi

- 版本管理：git 2.39+  https://git-scm.com/downloads

- 连接工具：根据自己习惯选择ssh客户端（xshell、finalshell……等），mysql客户端（Navicat、Sqlyog……等）

- 虚拟机环境：vmware虚拟机，建议版本 17+：https://pan.baidu.com/s/1xHdtHM7mDz7Wa6bgpY5sVA?pwd=9g27



**3.基础知识**

- 虚拟机Vmware：（只学p1-10，vm安装阶段）https://www.bilibili.com/video/BV1n84y1i7td?p=7&vd_source=ddc87dbee3553336b61e8b37579bfd2d

- Git：https://www.bilibili.com/video/BV1FE411P7B3?p=1&vd_source=ddc87dbee3553336b61e8b37579bfd2d

- Idea的使用：https://www.bilibili.com/video/BV1he4y1s7Yb/?spm_id_from=333.337.search-card.all.click&vd_source=ddc87dbee3553336b61e8b37579bfd2d

- Mysql：（只学前部到sql阶段）https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.337.search-card.all.click&vd_source=ddc87dbee3553336b61e8b37579bfd2d

- redis: https://www.boxuegu.com/course/outline-2477.html

- rabbitmq: https://www.bilibili.com/video/BV1mN4y1Z7t9?p=8&vd_source=ddc87dbee3553336b61e8b37579bfd2d







# 2、启动项目⭐️⭐️⭐️

要完成项目开发，首先需要我们在本地启动所有项目，包括三个Javaweb项目（backend、api、msg）、一个Openresty服务器，整体系统架构参考如下：

![image-20241101145532511](images/image-20241101145532511.png)

备注：

- 实线：Openresty服务器提供给用户访问的页面和接口数据流向
- 虚线：后台服务之间的数据流向



## 2.1 任务目标

**任务周期：2天**

1. 启动Java项目：在Idea中启动backend、api、msg三个Javaweb项目
2. 启动Openresty：下载并启动Openresty，能够通过Openresty集成前台页面+后台接口的正常访问
3. 梳理系统功能与设计：梳理系统中的业务功能+软件设计，产出xmind文档




## 2.2 执行与验收

### 2.2.1 启动Java项目

**1.解压代码并创建分支**

- 代码在 https://gitee.com/380014953/lottery-dev.git
- 备选离线包：【课程包/文档】目录下的  lottery.zip中


```shell
#注意，代码目录的全路径上只能使用英文字母和数字，禁止出现中文、特殊字符、空格等

# git clone https://gitee.com/380014953/lottery-dev.git

# git checkout -b zhangsan
切换到一个新分支 'zhangsan'

# git branch
* zhangsan
```



**2.熟悉项目代码结构：**

- backend是需要启动的管理后台，Springboot项目
- api，msg是需要启动的两个前台，Springboot项目

<img src="images/image-20231117%E4%B8%8A%E5%8D%88112526885.png" alt="image-20231117上午112526885" style="zoom:50%;" />



- commons里有一些对应的工具类，无需启动：

<img src="images/image-20231123%E4%B8%8A%E5%8D%88110737959.png" alt="image-20231123上午110737959" style="zoom:50%;" />



更多内容可以参考《设计文档》第 2.1、2.3 章节



**3.启动backend**

- 找到backend包下的：RuoYiApplication类，启动里面的main方法，然后访问： http://localhost:8888    

- 使用 user / 111111 进入管理后台，确保成功打开登录后的界面：【提交结果截图】


![image-20240103上午100129577](images/image-20240103%E4%B8%8A%E5%8D%88100129577.png)



**4.启动frontend下的api及msg**

- 分别在api及msg下找到Springboot的启动类，运行里面的main方法，确保在控制台看到成功启动后的端口号


以下以api为例，msg雷同：

![image-20231117上午113553179](images/image-20231117%E4%B8%8A%E5%8D%88113553179.png)



- 访问swagger： http://localhost:9001/doc.html  ，点击测试模块下的接口，能够呈现返回的json数据 【提交结果截图】


![image-20231117上午113719300](images/image-20231117%E4%B8%8A%E5%8D%88113719300.png)



### 2.2.2 启动Openresty

**1.下载Openresty，地址： http://openresty.org/en/download.html**

- windows：下载完成后，将它解压到本地目录，注意：这个目录的全路径，只能出现英文和数字，禁止中文、特殊字符、空格等
- Mac：brew安装后的目录无需关注，会自动安装到系统指定路径

![image-20241021145626662](images/image-20241021145626662.png)



**2.找到代码里的h5文件夹，把整个文件夹拷贝到openresty的静态文件目录里**

![image-20241021152010957](images/image-20241021152010957.png)



**小提示：静态文件目录，windows和mac不同**

- windows在： 解压目录/openresty-xxx/html
- mac一般在： /usr/local/var/www   (这取决于你本地的环境和版本）



**3.修改openresty的配置文件为以下内容**

```nginx
worker_processes  1;
events {
        worker_connections  1024;
}
http {

    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
    server {
        listen       80;
        server_name localhost;
        location ^~ /api/ {
                proxy_pass http://127.0.0.1:9001;
        }
        location / {
                root 【上面第2小节拷贝后的h5文件夹的绝对路径】;
        }
    }
}

```



**小提示：配置文件的位置，windows和mac不同**

- windows位于：解压目录/openresty-xxx/conf/nginx.conf

- mac通常位于以下三个地方（取决于你的安装方式和配置）

  `/usr/local/etc/nginx/nginx.conf`（Homebrew默认）

  `/opt/homebrew/etc/nginx/nginx.conf`（ARM架构的Mac，如M1/M2）

  `/usr/local/etc/openresty/nginx.conf`



**注意事项：（非常重要！！！）**

粘贴以上代码前，将root一行的 【上面第2小节拷贝后的h5文件夹的绝对路径】 部分修改成你的实际路径

- windows下类似这样：(注意分隔符为双斜杠  \\ \  )

  ```
  root D:\\src\\openresty-1.25.3.1-win64\\html\\h5\\;
  ```

- mac下类似这样：

  ```
  root /usr/local/var/www/h5/;
  ```

  

**4.启动Openresty，验证前后台集成环境**

访问http://localhost，将你看到的页面截图提交日报 【提交结果截图】





### 2.2.3 梳理系统功能与设计

**1.熟悉数据库及工具类**

- 熟悉表结构：需要关注 card_xxx表，view_xxx的视图，其他表属于管理后台的系统表，可以忽略

- 熟知各个字段的意义：使用客户端工具逐个打开各个数据表，熟悉字段上的备注

- 熟悉commons模块里的工具类：使用Idea逐个打开commons下的Java代码，熟悉相关方法和注释



**2.梳理系统业务功能，输出思维导图**

建议使用xmind，或者你熟悉的任意其他思维导图软件，参考样例如下：【提交结果截图】

<img src="images/image-20231122%E4%B8%8A%E5%8D%88111727530.png" alt="image-20231122上午111727530" style="zoom:50%;" />





**3.梳理系统软件设计思路，输出思维导图**

参考样例如下：【提交结果截图】

<img src="images/image-20231122%E4%B8%8A%E5%8D%88113253920.png" alt="image-20231122上午113253920" style="zoom:50%;" />



**小提示：**

- 你认为这个项目有哪些痛点？
- 你认为如何设计来解决这些痛点

- 还有哪些想到的问题或建议？





## 2.3 参考资料

- springboot: https://www.bilibili.com/video/BV1Lq4y1J77x/?spm_id_from=333.337.search-card.all.click&vd_source=ddc87dbee3553336b61e8b37579bfd2d
- mybatis的使用：https://www.bilibili.com/video/BV1MT4y1k7wZ?p=2&vd_source=ddc87dbee3553336b61e8b37579bfd2d

- Spring官网： https://spring.io/projects/spring-boot#support

- 管理后台框架，若依官网：http://ruoyi.vip  （基于MIT开源协议，可商用、修改、发行，保留LICENSE即可）





# 3、用户模块开发⭐️⭐️⭐️

用户模块涵盖了前台用户的一系列业务功能，包括：用户的登录、退出、个人信息、中奖信息

本小节需要完成这些核心接口的代码并按3.2里的提示，在【提交结果截图】的地方截取运行结果写入日报。



## 3.1 任务目标

1. 完成LoginController里的代码，提交运行结果到日报
2. 完成UserController里的代码，提交运行结果到日报
3. 校验页面数据展示




**任务周期：1 Day**



## 3.2 执行与验收

提示：commons里的 com.itheima.prize.commons.db.entity.XXX 可以作为 ApiResult里的data属性使用

### 3.2.1 完成LoginController代码

**1.完成以下位置代码编写**

![image-20231122上午114555948](images/image-20231122%E4%B8%8A%E5%8D%88114555948.png)



**2.接口自测通过，获取到以下结果：【提交结果截图】**

![image-20231122下午120054742](images/image-20231122%E4%B8%8B%E5%8D%88120054742.png)

![image-20231122下午120125991](images/image-20231122%E4%B8%8B%E5%8D%88120125991.png)

![image-20231122下午43209616](images/image-20231122%E4%B8%8B%E5%8D%8843209616.png)

![image-20231122下午32753364](images/image-20231122%E4%B8%8B%E5%8D%8832753364.png)



### 3.2.2 完成UserController代码

**1.完成以下代码编写**

![image-20231122上午114432968](images/image-20231122%E4%B8%8A%E5%8D%88114432968.png)



**2.接口自测通过，得到以下结果：【提交结果截图】**

提示：用户信息直接从session获取user属性即可

![image-20231122下午45339345](images/image-20231122%E4%B8%8B%E5%8D%8845339345.png)



**3.测试参与的活动列表，得到以下结果：【提交结果截图】**

- 在完成活动抽奖接口之前，json里的data无数据是正常的，可以在card_user_hit中手工录入测试数据检验接口

- 录入后，要获取查询结果可以使用视图：view_card_user_hit


![image-20231122下午52326794](images/image-20231122%E4%B8%8B%E5%8D%8852326794.png)



### 3.2.3 校验页面数据展示

**1.测试前端页面的登录、退出、个人中心，得到以下结果 【提交结果截图】**

![image-20231127下午21109886](images/image-20231127%E4%B8%8B%E5%8D%8821109886.png)



## 3.3 参考资料

**1.相关文档：**

参考《接口文档.xlsx》用户模块部分



**2.用户密码设计：**

用户的密码用Md5加密后再存储到数据库字段，同时登录验证时，把用户输入的密码加密后，再和数据库字段的值来比对



**3.登录安全性设计：**

登录需要验证密码错误次数，超过5次后，冻结5分钟并直接返回账户冻结提示，可以借助redis的incr操作实现计数



**4.个人信息安全性设计：**

所有接口返回到前台的数据里，注意保护用户敏感信息，把账户密码身份证等信息设置成null再返回json



**5.分布式环境下的session方案：**

项目已经集成spring redis session框架，登录成功后直接使用session来设置一个user属性，存储当前用户信息，即可通过登录校验

```java
session.setAttribute("user",user);  //后续的请求，如果session里没有设置user这个属性，将被认为未登录！
```



**6.接口返回的数据规范：**

所有接口返回json体必须是 com.itheima.prize.commons.utils.ApiResult，详细内容可以查看controller方法上的注释

接口详细内容参考《接口文档.xlsx》



**7.分页实现方案：**

Mybatis-Plus可以轻松实现分页，分页的返回数据使用PageBean对象来包装

```java
//一个使用分页代码的例子：
QueryWrapper<CardGame> gameQueryWrapper = new QueryWrapper<>();
Page<CardGame> page = gameService.page(new Page<>(curpage,limit),gameQueryWrapper);
return new ApiResult(1,"成功",new PageBean<CardGame>(page));
```



**8.视图有什么用？**

以下这些视图在查询中，可以直接获取到组合后的数据，详细字段使用mysql客户端工具打开视图结构可以查看到：

<img src="images/image-20231123%E4%B8%8A%E5%8D%88113205404.png" alt="image-20231123上午113205404" style="zoom:80%;" />





# 4、活动模块开发⭐️⭐️

活动模块的接口，为前台提供活动相关的数据展示，主要涉及到以下4个地方：首页的活动列表、活动详情页里的活动信息、活动对应的奖品信息、活动对应的中奖列表，本小节需要开发完对应的接口，并能提供正确的数据和页面展示。



## 4.1 任务清单

1. 完成GameController代码编写
2. 完成接口在Swagger里的测试
3. 完成页面校验





**任务周期：1 Day**



## 4.2 执行与验收

### 4.2.1 完成GameController代码编写

包含四个接口：首页的活动列表接口、活动详情页里的活动信息接口、活动对应的奖品信息查询接口、活动对应的中奖列表接口

<img src="images/image-20231123%E4%B8%8A%E5%8D%88112516355.png" alt="image-20231123上午112516355" style="zoom:50%;" />

### 4.2.2 完成Swagger接口测试

 【以下小点，均需要提交测试通过的截图到日报】

**1.活动列表接口测试通过，得到以下结果：**

![image-20231123上午112626190](images/image-20231123%E4%B8%8A%E5%8D%88112626190.png)



**2.活动信息接口测试通过，得到以下结果：**

![image-20231123上午112820900](images/image-20231123%E4%B8%8A%E5%8D%88112820900.png)



**3.活动包含的奖品接口测试通过，得到以下结果：**

![image-20231123上午113406402](images/image-20231123%E4%B8%8A%E5%8D%88113406402.png)



**4.活动中奖列表接口测试通过，得到以下结果：**

![image-20231123上午113033647](images/image-20231123%E4%B8%8A%E5%8D%88113033647.png)



### 4.2.3 完成页面校验

验证前台页面的展示情况，涉及到首页、首页底部的分页、活动规则页，确保数据展示正常【提交截图到日报】

<img src="images/image-20231127%E4%B8%8B%E5%8D%8821406388.png" alt="image-20231127下午21406388" style="zoom:50%;" />



<img src="images/image-20231127%E4%B8%8B%E5%8D%8821614312.png" alt="image-20231127下午21614312" style="zoom:50%;" />



## 4.3 参考资料

**1.相关文档：**

《接口文档.xlsx》里活动模块部分



**2.便捷的查询方案：**

在写查询业务时，推荐直接使用这些视图对应的Service（如：ViewCardUserHitService）里的方法：

<img src="images/image-20231123%E4%B8%8A%E5%8D%88113205404-17224905139241.png" alt="image-20231123上午113205404" style="zoom:80%;" />





# 5、缓存预热⭐️⭐️⭐️⭐️⭐️

当活动真正开始时，用户瞬间同时点击红包，这会发生超高的并发，所以我们要把这些高频访问的数据提前加载进redis，这就要求我们详细设计好在Redis里如何存数据，用什么机制来存进去，参考视频教程如下：

《缓存预热设计》相关视频: https://pan.baidu.com/s/1Ifj0p768fyf0EMXFULxhAA?pwd=988x



## 5.1 任务清单

1. 完成缓存相关代码编写
2. 完成代码测试



**任务周期：2 Day**



## 5.2 执行与验收

### 5.2.1 完成缓存相关代码编写

**1.在msg项目下找到GameTask，完成execute里代码的编写，实现活动数据从Mysql读取并写入Redis**

提示：此方法每分钟自动被系统调度一次

![image-20231226下午32725424](images/image-20231226%E4%B8%8B%E5%8D%8832725424.png)



**2.完成缓存查询接口代码编写，用来验证某个活动是否在Redis里已经被写入**

备注：此接口前端页面并不用，为方便swagger调试查看缓存结果使用

提示：本接口可以根据活动id，直接从Redis里查出上一小节写入的所有信息，将其全部放在一个Map中，赋值给ApiResult的data属性再返回

![image-20231127下午31351286](images/image-20231127%E4%B8%8B%E5%8D%8831351286.png)



### 5.2.2 完成代码测试

【需要提交预热成功的缓存内容截图】

1. 在管理后台创建一个活动，注意这个活动的开始时间必须是未来1分钟后开始，确保要在任务调度执行前创建完成

2. 保持msg项目处于启动状态，盯紧控制台，验证活动到期1分钟前，能够正常输出预热日志信息，展示活动数据被写入到Redis

3. 用swagger访问缓存查询接口，返回缓存信息




提示：在管理后台创建活动数据时，要尽量配置全，包括：活动基本信息、活动奖品信息、活动的策略信息，同样缓存查询接口也要全部返回以上内容，包括生成的令牌桶（注意，Redis里List类型的令牌桶不要用pop，而是用redisUtil.lrange）

一个参考样例：

```json
{
  "code": 200,
  "msg": "缓存信息",
  "data": {
    "game_info_7": {
      "id": 7,
      "title": "超级女神",
      "pic": "/upload/images/girl.png",
      "info": "女神来抽奖",
      "starttime": "2023/11/20 18:50:23",
      "endtime": "2023/12/10 18:50:23",
      "type": 1,
      "status": 1
    },
    "game_tokens_7": {
			
      //***********************************************************//
      // 注意！实际Redis里的令牌是时间戳，返回前可以将其转成日期类型，方便查看//
      //***********************************************************//
      
      "2023-11-22 05:50:50.866": {
        "id": 5,
        "name": "美食大礼盒",
        "pic": "/upload/images/food.png",
        "info": "来自好利来的轻奢月饼，是家人食用，馈赠亲友的不二选择",
        "price": 1000,
        "amount": 200
      },

      ……

      "2023-11-22 06:15:04.434": {
        "id": 6,
        "name": "5积分",
        "pic": "/upload/images/555555.png",
        "info": "积分可以在积分商城兑换相应商品，例如5个积分可以兑换50元话费",
        "price": 500,
        "amount": 500
      },
      "2023-12-10 18:46:15.510": {
        "id": 10,
        "name": "青铜",
        "pic": "/upload/images/money.png",
        "info": "看上去和金子一样，但是不是",
        "price": 1,
        "amount": 100
      }
    },
    "game_maxgoal_7": {
      "0": 5,
      "1": 10
    },
    "game_maxenter_7": {
      "0": 10,
      "1": 20
    }
  },
  "now": "2023/11/27 15:15:38"
}
```





## 5.3 参考资料

**1.预热的设计思路：**

1. 在msg中写一个定时任务
2. 任务的内容是：每分钟扫描一遍card_game表
3. 把（开始时间 > 当前时间）&& （开始时间 <= 当前时间+1分钟）的活动及相关信息放入redis，完成预热



**2.代码参考逻辑**：

1. 查询1分钟内的活动
2. 循环遍历查询到的活动列表，挨个处理，假设当前取出的是A活动
3. 查询A相关的奖品列表及数量

4. 根据总数量生成奖品相关的令牌桶，详细设计参考**《缓存预热设计》视频**

5. 查询A相关的活动策略：允许的抽奖次数、中奖次数、中奖概率，放入Redis



**3.小提示：**

- 调度任务的代码要在msg项目下的GameTask里完成，此处已集成Spring调度框架

- commons模块下有个RedisKeys，已经定义了可用的Redis key前缀，可以直接使用，每个key上面均有注释



**4.更多内容参考：**

《设计文档》 第2.2.3章节



# 6、抽奖业务⭐️⭐️⭐️⭐️⭐️

抽奖是本项目中最核心的业务点。活动一旦开始，用户点击红包时，将会触发该模块里的抽奖接口。上一任务缓存的预热，为本接口提供了必要的数据准备。本接口将合理使用这些数据，完成抽奖整体的业务流程。

《抽奖接口设计》相关视频: https://pan.baidu.com/s/1Ifj0p768fyf0EMXFULxhAA?pwd=988x




## 6.1 任务清单

1. 完成抽奖业务的开发
2. 完成swagger接口测试
3. 完成页面验证



**任务周期：2 Day**



## 6.2 执行与验收

### 6.2.1 完成抽奖业务的开发

**1.完成抽奖接口的代码：**

![image-20231226下午33934162](images/image-20231226%E4%B8%8B%E5%8D%8833934162.png)



**2.完成中奖后异步消息消费端代码：**

<img src="images/image-20231127%E4%B8%8B%E5%8D%8840538728.png" alt="image-20231127下午40538728" style="zoom:50%;" />

### 6.2.2 完成swagger接口测试

**1.在swagger中调用抽奖接口返回json，确保覆盖《接口文档》中所列的各种情况。**

 【提交接口自测通过的截图】

![image-20231127下午40701625](images/image-20231127%E4%B8%8B%E5%8D%8840701625.png)



### 6.2.3 完成页面验证

**1.打开已开始的活动，进入详情页，点击落下的红包触发抽奖接口**

【提交前端抽奖成功的截图】：

<img src="images/image-20231127%E4%B8%8B%E5%8D%8840759390.png" alt="image-20231127下午40759390" style="zoom:50%;" />

**2.一直点击红包，直到中奖为止，进入个人中心验证我的奖品列表中出现所中的奖品**

【提交个人中心-中奖记录的截图】：

<img src="images/image-20231127%E4%B8%8B%E5%8D%8840856361.png" alt="image-20231127下午40856361" style="zoom:50%;" />





## 6.3 参考资料

**1.相关文档：**

**《接口文档.xlsx》**

**《设计文档》 第2.2.4章节**

**《设计文档》 第3.2、3.3章节**



**2.注意事项：**

- 抽奖接口是整个项目中并发度最高的一个点

- 抽奖接口的代码要做到只从Redis获取预热后的数据，而不要在Mysql里查询

- 中奖后的信息不要直接写入数据库，采用异步化策略，交给消息队列，由api模块发送消息，msg模块消费消息来入库



**3.小提示：**

- 抽奖流程里的（判断最大中奖次数、取令牌-判断-放回令牌）已经写好了lua脚本：tokenCheck.lua（阅读脚本内容，有详细注释）

- api模块下有个LuaScript，可以协助完成Redis里Lua脚本的调用，具体返回值可以查看方法上的详细注释

- 可以用返回的令牌做key去redis里找value拿到真实的奖品


- RabbitMq传输对象的时候，使用FastJson将对象转为字符串后传输，可以避免很多问题，接收到消息后，再转回对应对象。





# 7、关键接口压测⭐️⭐️⭐️

我们已明确抽奖接口是系统中并发度最高的接口，那么该接口的业务完成后，究竟能承载多少人同时参与抽奖？严谨的数据如何得出？这就需要用到本节的压测工作。压测工具可以模拟多人在线同时请求某个接口的场景，且模拟的人数灵活可调。




## 7.1 任务清单

1. 完成jmeter工具的安装和基本使用

2. 完成抽奖接口压测，提交自己本机的压测结果数据



备注：本任务需要执行4次压测，每次模拟的人数和请求数不同：

100个用户，每个用户1000次

100个用户，每个用户10000次

1000个用户，每个用户1000次

1000个用户，每个用户10000次





**任务周期：1 Day**





## 7.2 执行与验收

### 7.2.1 完成jmeter配置

jmeter官网下载地址：https://jmeter.apache.org/ ，本次使用版本：5.6.2

下载后解压到笔记本的某个目录，找到 bin/jmeter.bat (或sh)，windows下双击启动，mac或linux用终端sh启动



**1.定义变量：压测的主机、端口、活动id，Value值要配置成你要压测的机器**

![image-20231130下午20704555](images/image-20231130%E4%B8%8B%E5%8D%8820704555.png)



**2.定义线程组：模拟100个用户**

![image-20231130下午20549706](images/image-20231130%E4%B8%8B%E5%8D%8820549706.png)



**3.添加cookie控制器：不然后续抽奖无法获取登录的cookie会提示未登录**

![image-20231130下午20801875](images/image-20231130%E4%B8%8B%E5%8D%8820801875.png)



**4.添加登录接口：照着以下图示配置即可**

![image-20231130下午20930729](images/image-20231130%E4%B8%8B%E5%8D%8820930729.png)



**5.加个循环控制器，里面放上抽奖接口**

![image-20231130下午21025106](images/image-20231130%E4%B8%8B%E5%8D%8821025106.png)



**6.在循环控制器内部添加抽奖接口：**

![image-20231130下午21102725](images/image-20231130%E4%B8%8B%E5%8D%8821102725.png)



**7.添加结果树和聚合报告：用于压测结果的查看和收集**

![image-20231130下午21158525](images/image-20231130%E4%B8%8B%E5%8D%8821158525.png)





### 7.2.2 读懂压测结果

**1.等候压测结束，得到压测的结果** 【需要提交截图到日报】

![image-20231130下午120005512](images/image-20231130%E4%B8%8B%E5%8D%88120005512.png)



**2.解读压测结果**

备注：以下使用测试环境的机器，1台阿里云的公网主机作为例子来分析



1）Samples样本数据：

模拟了100个人登录，每个人登录后狂点1000次，总抽奖次数10w，加登录的100个请求，共10w零100



2）下面我们忽略登录这个操作，重点看需要超高并发的抽奖接口：

Average - 99%Line：

- 平均响应时间45ms

- 50%的请求 <= 42ms

- 90%的请求 <= 55ms

- 95%的请求 <= 62ms

- 99%的请求 <= 95ms

结论：99%的人不到100ms。



3）Min/Maximum/Error部分

- 最小29ms，最大781ms，考虑99%的人在100ms以内，可以猜测有少量请求网络波动或并发阻塞造成时间超长

- 平均值大于中位数，说明随请求数增多响应时长的增速变快，呈曲线向上弯曲


- 无错误请求，全部正确响应




3）核心指标Throuphput：

- QPS 1814，吞吐量ok，也就意味着这100个人每秒点击屏幕能支持到18.4次，一般人没这个手速

- 作弊器除外，针对屏幕作弊器可以在Nginx层做ip限流到正常人的点击速度范围内。



## 7.3 参考资料

**1.压测前做好数据准备**

打压前要提前创建好活动，并且确保活动已处于开始状态






# 8、生产环境部署⭐️⭐️⭐️⭐️

项目开发完成后，实际的部署环节会由公司运维人员负责完成。故本小节为选做章节。适合想要拓展视野，了解上线流程的同学。

【此任务选做】



## 8.1 任务清单

1. 完成项目的部署：在虚拟机、或者云主机等生产环境上完整部署所有服务

2. 完成完整测试：可以正常访问部署的项目，并跑通全部业务



**任务周期：1 Day**



## 8.2 执行与验收

### 8.2.1 完成项目的部署

准备一台虚拟机或者云主机，使用docker完成以下内容的全量部署：【提交部署启动成功的截图】

- 中间件：Mysql、Rabbitmq、Redis、Minio、Nginx
- 后台服务：api、msg、backend




### 8.2.2 完成完整测试

 完成一个完整的抽奖成功的页面截图，包含以下关键点：【提交结果截图】

- 首页、活动抽奖页、活动规则页、个人中心页截图

- 抽奖中奖效果截图



## 8.3 参考资料

**1.详细内容参考《设计文档》 第3.6章节**

- 回顾：在前面实习中我们在本地环境中是怎样运行项目的？

- 部署思路：生产中建议使用docker-compose完成全部服务的部署



**2.服务器环境方案：**

可以申请一台云主机，也可以准备一台空的虚拟机作为代替和演练



**3.docker-compose参考视频：**

https://www.bilibili.com/video/BV1ed4y1o7HF



**4.docker-compose安装方案：**

在环境安装包中已经放置了docker-compose程序，可以拷贝到你的服务器上，放在 /usr/local/bin/ 目录下，然后添加执行权限：

```shell
chmod +x /usr/local/bin/docker-compose
docker-compose -v
> docker-compose version 1.24.1, build 4667896b
```

